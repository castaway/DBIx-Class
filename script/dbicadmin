#!/usr/bin/perl

use strict;
use warnings;

BEGIN {
  use DBIx::Class;
  die (  "The following modules are required for the dbicadmin utility\n"
       . DBIx::Class::Optional::Dependencies->req_missing_for ('admin_script')
  ) unless DBIx::Class::Optional::Dependencies->req_ok_for ('admin_script');
}

use DBIx::Class::Admin::Descriptive;
#use Getopt::Long::Descriptive;
use DBIx::Class::Admin;

my $short_description = "utility for administrating DBIx::Class schemata";
my $synopsis_text =qq{ 
  deploy a schema to a database
  %c --schema=MyApp::Schema \
    --connect='["dbi:SQLite:my.db", "", ""]' \
    --deploy

  update an existing record
  %c --schema=MyApp::Schema --class=Employee \
    --connect='["dbi:SQLite:my.db", "", ""]' \
    --op=update --set='{ "name": "New_Employee" }'
}
;

my ($opts, $usage) = describe_options(
    "%c: %o",
  (
    ['Actions'],
    ["action" => hidden => { one_of => [
      ['create|c' => 'Create version diffs needs preversion',],
      ['upgrade|U' => 'Upgrade the database to the current schema '],
      ['install|I' => 'Install the schema version tables to an existing database',],
      ['deploy|d' => 'Deploy the schema to the database',],
      ['select|s'   => 'Select data from the schema', ],
      ['insert|i'   => 'Insert data into the schema', ],
      ['update|u'   => 'Update data in the schema', ], 
      ['delete|D'   => 'Delete data from the schema',],
      ['op:s' => 'compatiblity option all of the above can be suppied as --op=<action>'],
      ['help|h' => 'display this help', { implies => { schema_class => 'main' } } ],
      ['pod' => 'Output this usage as pod', { implies => { schema_class => 'main' } } ],
    ], required=> 1 }],
    ['Arguments'],
    ['schema-class|schema|C:s' => 'The class of the schema to load', { required => 1 } ],
    ['resultset|resultset_class|class|r:s' => 'The resultset to operate on for data manipulation' ],
    ['config-stanza|S:s' => 'Where in the config to find the connection_info, supply in form MyApp::Model::DB',],
    ['config|f:s' => 'Supply the config file for parsing by Config::Any', { depends => 'config_stanza'} ],
    ['connect-info|n:s%' => 'Supply the connect info as additonal options ie -I dsn=<dsn> user=<user> password=<pass> '],
    ['connect:s' => 'Supply the connect info as a json string' ],
    ['sql-dir|q:s' => 'The directory where sql diffs will be created'],
    ['sql-type|t:s' => 'The RDBMs flavour you wish to use'],
    ['version|v:i' => 'Supply a version install'],
    ['preversion|p:s' => 'The previous version to diff against',],
    ['set:s' => 'JSON data used to perform data operations' ],
    ['attrs:s' => 'JSON string to be used for the second argument for search'],
    ['where:s' => 'JSON string to be used for the where clause of search'],
    ['force' => 'Be forceful with some operations'],
    ['trace' => 'Turn on DBIx::Class trace output'],
    ['quiet' => 'Be less verbose'],
  )
);

die "please only use one of --config or --connect-info\n" if ($opts->{config} and $opts->{connect_info});

if($opts->{pod}) {
    $usage->synopsis($synopsis_text);
    $usage->short_description($short_description);
    print $usage->pod();
    exit 0;
}

if($opts->{help}) {
    $usage->die();
}

# option compatability mangle
if($opts->{connect}) {
  $opts->{connect_info} = delete $opts->{connect};
}

my $admin = DBIx::Class::Admin->new( %$opts );


my $action = $opts->{action};

$action = $opts->{op} if ($action eq 'op');

print "Performig action $action...\n";

my $res = $admin->$action();
if ($action eq 'select') {

  my $format = $opts->{format} || 'tsv';
  die('Invalid format') if ($format!~/^tsv|csv$/s);

  require Text::CSV;

  my $csv = Text::CSV->new({
    sep_char => ( $format eq 'tsv' ? "\t" : ',' ),
  });

  foreach my $row (@$res) {
    $csv->combine( @$row );
    print $csv->string()."\n";
  }
}


#__END__
#
#=begin pod_begin
#
#BEGIN MARKER FOR DYNAMIC POD
#
#=end pod_begin
#
#=begin pod_end
#
#END MARKER FOR DYNAMIC POD
#
#=end pod_end
#
#=head1 AUTHOR
#
#See L<DBIx::Class/CONTRIBUTORS>.
#
#=head1 LICENSE
#
#You may distribute this code under the same terms as Perl itself
#
#=cut

# vim: et ft=perl
